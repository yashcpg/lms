Great — let’s define all the core entity models based on the plan. I’ll structure them using Entity Framework Core annotations for PostgreSQL compatibility.


---

1. User.cs

public class User
{
    public int Id { get; set; }
    public string Username { get; set; } = string.Empty;
    public string Email { get; set; } = string.Empty;
    public string PasswordHash { get; set; } = string.Empty;
    public UserRole Role { get; set; } = UserRole.Employee;
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

    public ICollection<LeaveRequest> LeaveRequests { get; set; }
    public ICollection<LeaveBalance> LeaveBalances { get; set; }
}

2. Enum: UserRole.cs

public enum UserRole
{
    Employee,
    Manager,
    Admin
}


---

3. LeaveType.cs

public class LeaveType
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public int DefaultAllocation { get; set; }

    public ICollection<LeaveRequest> LeaveRequests { get; set; }
    public ICollection<LeaveBalance> LeaveBalances { get; set; }
}


---

4. LeaveBalance.cs

public class LeaveBalance
{
    public int Id { get; set; }

    public int UserId { get; set; }
    public User User { get; set; }

    public int LeaveTypeId { get; set; }
    public LeaveType LeaveType { get; set; }

    public int Total { get; set; }
    public int Used { get; set; }
    public int Remaining => Total - Used;
}


---

5. LeaveRequest.cs

public class LeaveRequest
{
    public int Id { get; set; }

    public int EmployeeId { get; set; }
    public User Employee { get; set; }

    public int LeaveTypeId { get; set; }
    public LeaveType LeaveType { get; set; }

    public DateTime StartDate { get; set; }
    public DateTime EndDate { get; set; }
    public string Reason { get; set; } = string.Empty;

    public LeaveStatus Status { get; set; } = LeaveStatus.Pending;

    public int? ManagerId { get; set; }
    public User? Manager { get; set; }

    public DateTime RequestedAt { get; set; } = DateTime.UtcNow;
    public DateTime? ReviewedAt { get; set; }
    public string? ReviewerComments { get; set; }
}


---

6. Enum: LeaveStatus.cs

public enum LeaveStatus
{
    Pending,
    Approved,
    Rejected,
    Canceled
}


---

7. Notification.cs

public class Notification
{
    public int Id { get; set; }

    public int UserId { get; set; }
    public User User { get; set; }

    public string Message { get; set; } = string.Empty;
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public bool IsRead { get; set; } = false;
}


---

Next Step

Now that we have models ready, next is setting up:

DbContext class (AppDbContext)

Relationship mapping

Migration and PostgreSQL setup


Let me know if you’re ready for that, or if you want the folder structure scaffolding first.
Awesome — let’s set up the DbContext and configure the relationships for PostgreSQL using Entity Framework Core.


---

1. Create AppDbContext.cs

using Microsoft.EntityFrameworkCore;

public class AppDbContext : DbContext
{
    public AppDbContext(DbContextOptions<AppDbContext> options) : base(options) {}

    public DbSet<User> Users { get; set; }
    public DbSet<LeaveType> LeaveTypes { get; set; }
    public DbSet<LeaveBalance> LeaveBalances { get; set; }
    public DbSet<LeaveRequest> LeaveRequests { get; set; }
    public DbSet<Notification> Notifications { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        // User
        modelBuilder.Entity<User>()
            .HasIndex(u => u.Email)
            .IsUnique();

        // LeaveBalance
        modelBuilder.Entity<LeaveBalance>()
            .HasOne(lb => lb.User)
            .WithMany(u => u.LeaveBalances)
            .HasForeignKey(lb => lb.UserId);

        modelBuilder.Entity<LeaveBalance>()
            .HasOne(lb => lb.LeaveType)
            .WithMany(lt => lt.LeaveBalances)
            .HasForeignKey(lb => lb.LeaveTypeId);

        // LeaveRequest
        modelBuilder.Entity<LeaveRequest>()
            .HasOne(lr => lr.Employee)
            .WithMany(u => u.LeaveRequests)
            .HasForeignKey(lr => lr.EmployeeId)
            .OnDelete(DeleteBehavior.Restrict);

        modelBuilder.Entity<LeaveRequest>()
            .HasOne(lr => lr.Manager)
            .WithMany()
            .HasForeignKey(lr => lr.ManagerId)
            .OnDelete(DeleteBehavior.Restrict);

        // Notification
        modelBuilder.Entity<Notification>()
            .HasOne(n => n.User)
            .WithMany()
            .HasForeignKey(n => n.UserId);
    }
}


---

2. Register EF Core & PostgreSQL in Program.cs

Make sure you’ve added the NuGet package:

dotnet add package Npgsql.EntityFrameworkCore.PostgreSQL

Then configure it in Program.cs:

builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseNpgsql(builder.Configuration.GetConnectionString("DefaultConnection")));


---

3. Add Connection String in appsettings.json

"ConnectionStrings": {
  "DefaultConnection": "Host=localhost;Port=5432;Database=LeaveManagementDB;Username=postgres;Password=yourpassword"
}


---

4. Add Migrations & Update Database

Run the following commands in terminal:

dotnet ef migrations add InitialCreate
dotnet ef database update


---

Let me know when this is done, and we’ll move to DTOs and Authentication setup (JWT + Register/Login).

